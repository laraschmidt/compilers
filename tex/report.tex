%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% writeLaTeX Example: Academic Paper Template
%
% Source: http://www.writelatex.com
% 
% Feel free to distribute this example, but please keep the referral
% to writelatex.com
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[twocolumn,showpacs,%
  nofootinbib,aps,superscriptaddress,%
  eqsecnum,prd,notitlepage,showkeys,10pt]{revtex4-1}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{dcolumn}
\usepackage{hyperref}
\usepackage{listings}

\begin{document}

\title{Javascript Language Extensions}
\author{Esha Choukse, Lara Schmidt}


\maketitle

\section{Introduction And Project Goals} 
V8 is a compiler for javascript that is designed to make javascript as fast as possible. It has many optimizations and features. However one thing that V8 does not provide is a way for a developer or user to provide 'hints' to the compiler. Optimizing takes time and V8 doesn't want to lose time optimizing when it doesn't need to. For example it won't optimize a function until it is 'hot'. So therefore, by allowing the compiler to take hints about whether or not it should optimize a function, we can allow V8 to gain even more speed. There have been a few papers in the past that have explored similar things, \cite{}, however not ones that have explored in particular V8 and javascript optimizations.

\section{API}
We implemented three optimizations to prototype our ideas. A developer could implement these by adding code into the specific javascript file. The deverloper defines an optimization by function. This was because V8's optimization and code-tracking is done per function. The first optimization was 'Optimize Immediately'. This optimization would optimize a function immediatly upon it's creation. The second optimization was 'Never Optimize'. This would cause a function to never attempt to be optimized. The third optimization was 'Optimize After X runs'. This would cause the function to be marked for optimization after X runs. 

The programmer would specify these optimizations inside a multiline comment with a special header. They would also specify the function name and the respective optimization. An int was used to make parsing easier. 0 for 'Optimize Immediately', 1 for 'Never optimize' and 2 for 'Optimize after X runs'. The 'Optimize after X runs' was followed by another int that specified the given X. For example:
\begin{lstlisting}
/*LEZ
fname1,0;
fname2,2,100;
fname3,1;
*/
\end{lstlisting}
In this example fname will be optimized immediately, fname2 will be optimized after 100 runs, and fname3 will be never optimized. One could give several optimizations to one function by just putting the function name in several lines, however in the case of these three optimizations it doesn't make sense as they are opposing optimizations.

We also wanted to provide an ability for the user to optimize the javascript without the developer. So we created a Chrome browser extension that would insert code into the javascript and cause our optimizations to be run. The browser inserted the javascript comments into a script tag at the beginning of html pages before the page was ran, allowing it to be reached first by V8. For a prototype we just allowed the user to have a set of saved optimizations that was then inserted into pages on a certain domain, however one can see how it could be extended to allow the user to specify different optimizations for different pages.

\section{Implementation}
The implementation of these optimizations is actually fairly simple. However V8 is a heavily regimented and organized code-base and we will explain the difficulties with this in the next section. In V8 there is a structure called the Isolate. The isolate seems to be a representation for a thread in V8 or when used by Chrome a 'tab' in the Chrome browser. It appears to have it's own heap and garbage collection. In our code we use the Isolate as similar to 'global state'.

Our implementation first searches the first three characters of all multiline comments looking for the signature 'LEZ'. If this is found, it calls our code to begin parsing. It then adds these code into the isolate (which we added implementation to access the isolate at this point). We store a map in the isolate with the key of function name and the value a pointer to a malloced int *. The first int in the array is a bit map where each bit corresponds to whether an optimization is 'on' or 'off'. The other spots in the array are for extra information like for example the X in 'Deopt after X'. The locations of these values are hard-coded as defines to make it easy to access.

The next part was fairly tricky as we wanted to avoid having to do string based map lookups every time we wanted to find out if a funciton needed to be optimized. So we solved this problem by attaching the optimization data to a per-function data structure. There were several options: Code object, JSFunction object, and SharedFunctionInfo objects. All of these structures were heavily regimented as their total size was kept as well as offsets to each and there were requirements on their data. We decided to add it to SharedFunctionInfo because this object had a lot of information stored with it and was availabe from the JSFunction object. Also Code and JSFunction objects seem to be recreated and deleted often. We had to copy the int array into a structure that was used inside V8 and followed the requirements. This was done on creation of the SharedFunctionInfo and the information was pulled from the isolate with a map lookup. Note that we do have to do a hash map lookup for every function even if it is not optimized.

Once we had the data inside the SharedFunctionInfo object we could use it to actually make the optimizations. For the 'Optimize Always' optimization we made it do the optimization immediately by modifying a check in V8 that optimizes if the v8 'always\_opt' flag is on. To never optimize we tricked V8 into thinking that it shouldn't optimize by setting a reason in the SharedFunctionInfo to have deoptimized. For the third optimization 'Optimized after X' we modifyed code that wrote assembly code that set the something similar to a weighted counter to use our weight instead of a default flag.

\section {Difficulties}



\section{Analysis and Results}

\subsection{Opt 1: Optimize Immediately}
\subsection{Opt 2: Never Optimize}
\subsection{Opt 3: Optimized after k runs}

\subsection{Real Website Benchmarks}


\section {What we learned}
knowledge about v8

\section{Future Work}
\section{Conclusion}



% Commands to include a figure:
%\begin{figure}
%\includegraphics[width=\textwidth]{your-figure's-file-name}
%\caption{\label{fig:your-figure}Caption goes here.}
%\end{figure}

%\begin{table}
%\centering
%\begin{tabular}{l|r}
%tem & Quantity \\\hline
%Widgets & 42 \\
%Gadgets & 13
%\end{tabular}
%\caption{\label{tab:widgets}An example table.}
%\end{table}



\begin{thebibliography}{9}

\bibitem{book} Peterson, Larry L. and Davie, Bruce S. Computer Networks, Fifth Edition: A Systems Approach. 5th Ed. 2011.

\bibitem{typewiki} Wikipedia.org. Internet Media Types. \url{http://en.wikipedia.org/wiki/internet_media_type}.

\bibitem{MIMEwiki} Wikipedia.org. MIME. \url{http://en.wikipedia.org/wiki/MIME}
\bibitem{RSA} What is.com. S/MIME.  http://whatis.techtarget.com/definition/S-MIME-Secure-Multi-Purpose-Internet-Mail-Extensions
\bibitem{SMIMEwiki} Wikipedia.org. S/MIME. 
\url{http://en.wikipedia.org/wiki/S/MIME}




\end{thebibliography}

\end{document}